// File: src/App.js
import React, { useState, useRef, useEffect } from "react";
import { Stage, Layer, Image as KonvaImage, Transformer } from "react-konva";

const CANVAS_WIDTH = 1024;
const CANVAS_HEIGHT = 1024;
const QR_SIZE = 720;

function App() {
  const [qr, setQr] = useState(null);
  const [bg, setBg] = useState(null);
  const [params, setParams] = useState(null);

  const bgRef = useRef();
  const trRef = useRef();

  // Load sample QR image (put qr.png into public/)
  useEffect(() => {
    const img = new window.Image();
    img.src = process.env.PUBLIC_URL + "/qr.png";
    img.onload = () => setQr(img);
  }, []);

  const handleBgUpload = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const url = URL.createObjectURL(file);
    const img = new window.Image();
    img.src = url;
    img.onload = () => setBg(img);
  };

  const computeParams = () => {
    if (!bgRef.current) return null;
    const node = bgRef.current;

    const absPos = node.getAbsolutePosition();
    const scaleX = node.scaleX();
    const scaleY = node.scaleY();
    const rotation = node.rotation();
    const opacity = node.opacity();

    const qrX = (CANVAS_WIDTH - QR_SIZE) / 2;
    const qrY = (CANVAS_HEIGHT - QR_SIZE) / 2;

    const w = node.width() * scaleX;
    const relX = (absPos.x - qrX) / QR_SIZE;
    const relY = (absPos.y - qrY) / QR_SIZE;
    const relW = w / QR_SIZE;

    return {
      canvasWidth: CANVAS_WIDTH,
      canvasHeight: CANVAS_HEIGHT,
      qrSizePx: QR_SIZE,
      transform: {
        relX,
        relY,
        relW,
        rotation,
        anchorAx: 0.5,
        anchorAy: 0.5,
        opacity,
      },
    };
  };

  // Keep JSON live updated
  useEffect(() => {
    const anim = setInterval(() => {
      const p = computeParams();
      if (p) setParams(p);
    }, 300);
    return () => clearInterval(anim);
  }, [bg]);

  const handleSubmit = async () => {
    const p = computeParams();
    if (!p || !qr || !bg) return;

    const form = new FormData();
    const qrBlob = await fetch(qr.src).then((r) => r.blob());
    const bgBlob = await fetch(bg.src).then((r) => r.blob());

    form.append("qr", qrBlob, "qr.png");
    form.append("bg", bgBlob, "bg.png");
    form.append("params", JSON.stringify(p));

    const res = await fetch("http://localhost:8080/api/compose", {
      method: "POST",
      body: form,
    });

    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    window.open(url, "_blank");
  };

  return (
    <div>
      <h1>QR + Background Composer</h1>
      <input type="file" accept="image/*" onChange={handleBgUpload} />
      <button onClick={handleSubmit}>Send to Backend</button>

      <Stage
        width={CANVAS_WIDTH}
        height={CANVAS_HEIGHT}
        style={{ border: "1px solid black", marginTop: "1rem" }}
      >
        <Layer>
          {qr && (
            <KonvaImage
              image={qr}
              x={(CANVAS_WIDTH - QR_SIZE) / 2}
              y={(CANVAS_HEIGHT - QR_SIZE) / 2}
              width={QR_SIZE}
              height={QR_SIZE}
            />
          )}
          {bg && (
            <>
              <KonvaImage
                image={bg}
                ref={bgRef}
                x={CANVAS_WIDTH / 2 - bg.width / 4}
                y={CANVAS_HEIGHT / 2 - bg.height / 4}
                width={bg.width / 2}
                height={bg.height / 2}
                draggable
                onClick={() => {
                  trRef.current.nodes([bgRef.current]);
                  trRef.current.getLayer().batchDraw();
                }}
                onTap={() => {
                  trRef.current.nodes([bgRef.current]);
                  trRef.current.getLayer().batchDraw();
                }}
              />
              <Transformer ref={trRef} />
            </>
          )}
        </Layer>
      </Stage>

      <h3>Debug JSON</h3>
      <pre style={{ background: "#f4f4f4", padding: "1rem" }}>
        {params ? JSON.stringify(params, null, 2) : "{}"}
      </pre>
    </div>
  );
}

export default App;