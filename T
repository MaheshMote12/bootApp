// File: src/main/java/com/example/qr/ComposeApp.java
package com.example.qr;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.io.*;
import java.util.Objects;

/**
 * Spring Boot app that centers a QR on a canvas and overlays a background image
 * using transform values RELATIVE to the QR box.
 */
@SpringBootApplication
public class ComposeApp {
    public static void main(String[] args) {
        SpringApplication.run(ComposeApp.class, args);
    }

    @RestController
    @RequestMapping("/api")
    public static class ComposeController {
        private final ObjectMapper mapper = new ObjectMapper();

        @PostMapping(value = "/compose", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
        public ResponseEntity<byte[]> compose(
                @RequestPart("qr") MultipartFile qrFile,
                @RequestPart("bg") MultipartFile bgFile,
                @RequestPart("params") String paramsJson
        ) throws Exception {

            Params params = mapper.readValue(paramsJson, Params.class);
            validate(params);

            // Load images
            BufferedImage qrImg = ImageIO.read(qrFile.getInputStream());
            BufferedImage bgImg = ImageIO.read(bgFile.getInputStream());
            if (qrImg == null) throw new IllegalArgumentException("Invalid QR image");
            if (bgImg == null) throw new IllegalArgumentException("Invalid background image");

            // Compose
            byte[] outPng = Composer.composeCentered(
                    qrImg,
                    bgImg,
                    params.canvasWidth,
                    params.canvasHeight,
                    params.qrSizePx,
                    params.transform
            );

            return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_DISPOSITION, "inline; filename=\"composed.png\"")
                    .contentType(MediaType.IMAGE_PNG)
                    .body(outPng);
        }

        private static void validate(Params p) {
            if (p.canvasWidth <= 0 || p.canvasHeight <= 0)
                throw new IllegalArgumentException("canvasWidth/canvasHeight must be > 0");
            if (p.qrSizePx <= 0 || p.qrSizePx > Math.max(p.canvasWidth, p.canvasHeight))
                throw new IllegalArgumentException("qrSizePx must be within canvas bounds");
            if (p.transform == null) throw new IllegalArgumentException("transform required");
            clamp01(p.transform);
        }

        private static void clamp01(Transform t) {
            t.relX = clamp(t.relX, -1, 2); // allow small overflow so user can move slightly outside QR
            t.relY = clamp(t.relY, -1, 2);
            t.relW = clamp(t.relW, 0, 5);  // allow oversize if desired
            t.anchorAx = clamp(t.anchorAx, 0, 1);
            t.anchorAy = clamp(t.anchorAy, 0, 1);
            t.opacity = (float) clamp(t.opacity, 0, 1);
        }

        private static double clamp(double v, double lo, double hi) {
            return Math.max(lo, Math.min(hi, v));
        }
    }

    /**
     * Core composer: QR centered on canvas; BG positioned relative to the QR box.
     */
    public static class Composer {

        public static byte[] composeCentered(BufferedImage qrImg,
                                             BufferedImage bgImg,
                                             int canvasW,
                                             int canvasH,
                                             int qrSizePx,
                                             Transform t) throws IOException {

            // Canvas
            BufferedImage canvas = new BufferedImage(canvasW, canvasH, BufferedImage.TYPE_INT_ARGB);
            Graphics2D g = canvas.createGraphics();
            try {
                // Quality hints (why: avoid aliasing when scaling/rotating)
                g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);
                g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
                g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

                // Fill transparent (or white if you prefer)
                g.setComposite(AlphaComposite.Clear);
                g.fillRect(0, 0, canvasW, canvasH);
                g.setComposite(AlphaComposite.SrcOver);

                // Centered QR box
                int qrX = (canvasW - qrSizePx) / 2;
                int qrY = (canvasH - qrSizePx) / 2;

                // Draw QR scaled to qrSizePx
                drawScaled(g, qrImg, qrX, qrY, qrSizePx, qrSizePx);

                // Background transform RELATIVE to QR box
                // Compute target top-left (in canvas coords)
                int targetW = (int) Math.round(t.relW * qrSizePx);
                if (targetW <= 0) return writePng(canvas); // nothing to draw

                double bgAspect = (double) bgImg.getHeight() / (double) bgImg.getWidth();
                int targetH = (int) Math.round(targetW * bgAspect);

                int targetX = (int) Math.round(qrX + t.relX * qrSizePx);
                int targetY = (int) Math.round(qrY + t.relY * qrSizePx);

                // Anchor in target pixels
                double anchorPx = t.anchorAx * targetW;
                double anchorPy = t.anchorAy * targetH;

                // Build affine transform: translate->anchor->rotate->scale->untranslate
                AffineTransform tx = new AffineTransform();
                tx.translate(targetX, targetY);
                tx.translate(anchorPx, anchorPy);
                tx.rotate(Math.toRadians(t.rotation));
                double sx = (double) targetW / bgImg.getWidth();
                double sy = (double) targetH / bgImg.getHeight();
                tx.scale(sx, sy);
                tx.translate(-t.anchorAx * bgImg.getWidth(), -t.anchorAy * bgImg.getHeight());

                // Opacity
                if (t.opacity < 1f) {
                    g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, Math.max(0f, Math.min(1f, t.opacity))));
                } else {
                    g.setComposite(AlphaComposite.SrcOver);
                }

                // Draw BG
                g.drawImage(bgImg, tx, null);

                // Optional: protect QR finder patterns here if needed.

            } finally {
                g.dispose();
            }
            return writePng(canvas);
        }

        private static void drawScaled(Graphics2D g, BufferedImage img, int x, int y, int w, int h) {
            g.drawImage(img, x, y, w, h, null);
        }

        private static byte[] writePng(BufferedImage img) throws IOException {
            try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
                ImageIO.write(img, "png", baos);
                return baos.toByteArray();
            }
        }
    }

    // ========= DTOs =========

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class Params {
        public int canvasWidth;
        public int canvasHeight;
        public int qrSizePx;

        public Transform transform;

        @Override public String toString() {
            return "Params{" +
                    "canvasWidth=" + canvasWidth +
                    ", canvasHeight=" + canvasHeight +
                    ", qrSizePx=" + qrSizePx +
                    ", transform=" + transform +
                    '}';
        }
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class Transform {
        /** top-left X relative to QR box (0..1 typical) */
        public double relX;
        /** top-left Y relative to QR box (0..1 typical) */
        public double relY;
        /** width relative to QR size (0..1 typical) */
        public double relW;
        /** degrees clockwise (positive) */
        public double rotation = 0.0;
        /** anchor inside bg [0..1], default center */
        public double anchorAx = 0.5;
        public double anchorAy = 0.5;
        /** 0..1 opacity */
        public float opacity = 1.0f;

        @Override public String toString() {
            return "Transform{" +
                    "relX=" + relX +
                    ", relY=" + relY +
                    ", relW=" + relW +
                    ", rotation=" + rotation +
                    ", anchorAx=" + anchorAx +
                    ", anchorAy=" + anchorAy +
                    ", opacity=" + opacity +
                    '}';
        }
    }
}